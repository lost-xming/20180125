
## 1、先来一打 浏览器运行机制再讲其他（内容有点长，注意身体）！

	官方的术语
		
		进程 是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）;

		线程 是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）;

	不同进程之间也可以通信，不过代价较大
	现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行

**浏览器是多进程的**
	
	理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）

	浏览器是多进程的
	浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）

	简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 正常情况下 进程会 +1；
		
	注意：在这里 浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了
	（所以每一个Tab标签对应一个进程并不一定是绝对的）

**那么浏览器都包含那些进程呢？**

	简化版： 
		1、Browser进程  浏览器的 主进程 （负责协调 、主控），有且只有一个；
			作用： 
				1）、负责浏览器界面显示，与用户交互。如前进，后退等
				2）、负责各个页面的管理，创建和销毁其他进程
				3）、将Renderer进程得到的内存中的Bitmap，绘制到用户界面上
				4）、网络资源的管理，下载等

		2、第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建；

		3、GPU进程：最多一个，用于3D绘制等

		4、浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。
			主要作用为：页面渲染，脚本执行，事件处理等
	
**浏览器多进程的优势**

		1、避免单个page crash影响整个浏览器
		2、避免第三方插件crash影响整个浏览器
		3、多进程充分利用多核优势
		4、方便使用沙盒模型隔离插件等进程，提高浏览器稳定性


**重点来了。。。。浏览器内核（渲染Renderer进程，内部是多线程）**
	
	此进程中包含着 以下线程：
		
		1、GUI渲染线程

			负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
			当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行
			注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），
			GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

		2、JS引擎线程

			也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
			JS引擎线程负责解析Javascript脚本，运行代码。
			JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序
			同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
		
		3、事件触发线程

			归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
			当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
			当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
			注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）

		4、定时触发器线程

			传说中的神器 setInterval与setTimeout所在线程 （没有是他们解决不了的问题，有那就是 一个定时器不够，那就再加一个）；
			浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
			因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
			注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
		
		5、异步http请求线程

			在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
			将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。

到了此处 能够理解的都是大神，不能理解也没有关系，请继续往下看 ，如果累 就请先休息下，因为看这些确实很烧脑。

**Browser进程和浏览器内核（Renderer进程）的通信过程**

	如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程
		（一个是主控进程，一个则是打开Tab页的渲染进程），
	然后在这前提下，看下整个的过程：(简化了很多)
	
	Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程
	Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
	
	渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
	当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）
	最后Render进程将结果传递给Browser进程
	Browser进程接收到结果并将结果绘制出来



请看下图：

![](http://47.97.165.187/images/fuhetuceng.jpg)

事件队列、现象2以及GPU 下文会做详细介绍；
先来说说 现象1；

**现象1以及类似问题**
	
	因为 JS线程和渲染线程是互斥的， 所以造成了，当CSS布局、渲染时，JS是停止执行的；JS 执行时 CSS样式表渲染是停止的；
	
	具体表象是 ：
		1、页面头部的<style></style> 会阻塞页面；
		2、页面头部<script</script>会阻塞页面；
		3、页面中空的 href 和 src 会阻塞页面其他资源的加载
	后面我会写一份 详细的 页面优化的篇幅，尽情期待哦！！！

## 事件队列

**现象2 JS 分为 同步 和 异步**

		同步任务都在主线程上执行，形成一个执行栈（即 同步任务JS解析引擎先执行）；
	
		异步任务 主要包含：事件触发的回调任务 ，Ajax请求回调任务 ，定时器回调任务等；
		
		在主线程外，事件触发线程还管理这一个 事件任务队列，只要事件任务 之中放置了一个事件， 
		一旦同步任务执行完毕后（此时js解析引擎空闲），系统就会读取任务队列中的异步任务 添加到可执行栈中 并开始执行 ， 
		如此循环；


异步任务中 请重点注意 定时器setTimeout / setInterval;

上文已经说了 异步任务是存在 事件队列中， 那么当队列中的任务爆多，那么定时器的异步回调 还能准时执行吗？ 请思考！！

同理  setInterval则是每次都精确的隔一段时间推入一个事件 , 如果时间 间隔过短 ，还能准时执行吗？ 

这样就造成了一个很严重的问题： 

**【累计效应】  如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行**；
**JS高程中有提到，JS引擎会对setInterval进行优化，如果当前事件队列中有setInterval的回调，不会重复添加，但还是有很多问题**

**事件队列补充**

上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：

		console.log('script start');
		
		setTimeout(function() {
		    console.log('setTimeout');
		}, 0);
		
		Promise.resolve().then(function() {
		    console.log('promise1');
		}).then(function() {
		    console.log('promise2');
		});
		
		console.log('script end');


		执行结果
		script start
		script end
		promise1
		promise2
		setTimeout

JS中分两种任务类型： macrotask和microtask ，在ECMAScript中，microtask称为jobs，macrotask可称为task；

**macrotask（又称之为宏任务）**

可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

	每一个task会从头到尾将这个任务执行完毕，不会执行其它
	浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染


**microtask（又称为微任务）**

可以理解是在当前 task 执行结束后立即执行的任务

	也就是说，在当前task任务后，下一个task之前，在渲染之前
	所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染
	也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

**分别很么样的场景会形成macrotask和microtask呢？**

	macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）
	microtask：Promise，process.nextTick等

请看下图：
	
![](http://47.97.165.187/images/renwuduilie.png)

上图不难看出， **微任务的查询和操作 都是在当前这个宏任务执行完毕后 ，CSS渲染前 ， 下一次宏任务前 执行的；**
 
**另外 ，此处的 渲染CSS （上文已经提到过） 也就是说 每一次异步任务后 有DOM操作造成的重绘重排 都会出现【回流】现象 ， 并且这里 如果异步任务中存在大量的数据计算 ，将会造成 页面巨卡无比。。。。。等着崩溃吧！！**

##GPU进程 
**GPU 的主要作用就是 ：是用于显卡硬件加速，提高你网页浏览的体验，特别是高清视频Flash播放 【这是度娘得到的】；**

对于我们前端来说： 你只要知道 这里可以启动硬件加速就可以了！

首先我们来了解下 ，浏览器的渲染图层一般 包含两大类 ： **普通图层** 以及 **复合图层**

	首先 默认的一个文档流 既是 一个复合图层 （默认的复合图层， 例如一个html 文档流）；

	其次 使用absolute布局（fixed），虽然脱离了文本流 但是 它还是属于这个默认复合图层的；

	然后，可以通过 硬件加速的 方式 声明一个 新复合图层 ，它会单独分配资源
	（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）

**可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒，但是很耗CPU ，很耗电**

**可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息**

**如何变成复合图层（硬件加速）**

	将该元素变成一个复合图层，就是传说中的硬件加速技术
	
	最常用的方式：translate3d、translateZ

	opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）

	will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，
	其它属性并不会变成复合层），

**硬件加速时请使用index**

简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意

写到这里， 对于浏览器的运转机制，已经写完了， 真累，不知道 看的你 会累吗？

取材于 [从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 "https://segmentfault.com/a/1190000012925872") 讲的真是 受益匪浅！！！
